// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package types

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson791538f0DecodeBlocsyInternalTypes(in *jlexer.Lexer, out *WSBlockMessage) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "result":
			if in.IsNull() {
				in.Skip()
				out.Result = nil
			} else {
				if out.Result == nil {
					out.Result = new(int)
				}
				*out.Result = int(in.Int())
			}
		case "params":
			if in.IsNull() {
				in.Skip()
				out.Params = nil
			} else {
				if out.Params == nil {
					out.Params = new(struct {
						Result *struct {
							Value struct {
								Slot  *int `json:"slot"`
								Block struct {
									BlockTime    *int64     `json:"blockTime,omitempty"`
									ParentSlot   *int       `json:"parentSlot,omitempty"`
									Transactions []SolanaTx `json:"transactions"`
								} `json:"block"`
							} `json:"value"`
						} `json:"result,omitempty"`
					})
				}
				easyjson791538f0Decode(in, out.Params)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes(out *jwriter.Writer, in WSBlockMessage) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Result != nil {
		const prefix string = ",\"result\":"
		first = false
		out.RawString(prefix[1:])
		out.Int(int(*in.Result))
	}
	if in.Params != nil {
		const prefix string = ",\"params\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjson791538f0Encode(out, *in.Params)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v WSBlockMessage) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v WSBlockMessage) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *WSBlockMessage) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *WSBlockMessage) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes(l, v)
}
func easyjson791538f0Decode(in *jlexer.Lexer, out *struct {
	Result *struct {
		Value struct {
			Slot  *int `json:"slot"`
			Block struct {
				BlockTime    *int64     `json:"blockTime,omitempty"`
				ParentSlot   *int       `json:"parentSlot,omitempty"`
				Transactions []SolanaTx `json:"transactions"`
			} `json:"block"`
		} `json:"value"`
	} `json:"result,omitempty"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "result":
			if in.IsNull() {
				in.Skip()
				out.Result = nil
			} else {
				if out.Result == nil {
					out.Result = new(struct {
						Value struct {
							Slot  *int `json:"slot"`
							Block struct {
								BlockTime    *int64     `json:"blockTime,omitempty"`
								ParentSlot   *int       `json:"parentSlot,omitempty"`
								Transactions []SolanaTx `json:"transactions"`
							} `json:"block"`
						} `json:"value"`
					})
				}
				easyjson791538f0Decode1(in, out.Result)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode(out *jwriter.Writer, in struct {
	Result *struct {
		Value struct {
			Slot  *int `json:"slot"`
			Block struct {
				BlockTime    *int64     `json:"blockTime,omitempty"`
				ParentSlot   *int       `json:"parentSlot,omitempty"`
				Transactions []SolanaTx `json:"transactions"`
			} `json:"block"`
		} `json:"value"`
	} `json:"result,omitempty"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Result != nil {
		const prefix string = ",\"result\":"
		first = false
		out.RawString(prefix[1:])
		easyjson791538f0Encode1(out, *in.Result)
	}
	out.RawByte('}')
}
func easyjson791538f0Decode1(in *jlexer.Lexer, out *struct {
	Value struct {
		Slot  *int `json:"slot"`
		Block struct {
			BlockTime    *int64     `json:"blockTime,omitempty"`
			ParentSlot   *int       `json:"parentSlot,omitempty"`
			Transactions []SolanaTx `json:"transactions"`
		} `json:"block"`
	} `json:"value"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "value":
			easyjson791538f0Decode2(in, &out.Value)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode1(out *jwriter.Writer, in struct {
	Value struct {
		Slot  *int `json:"slot"`
		Block struct {
			BlockTime    *int64     `json:"blockTime,omitempty"`
			ParentSlot   *int       `json:"parentSlot,omitempty"`
			Transactions []SolanaTx `json:"transactions"`
		} `json:"block"`
	} `json:"value"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"value\":"
		out.RawString(prefix[1:])
		easyjson791538f0Encode2(out, in.Value)
	}
	out.RawByte('}')
}
func easyjson791538f0Decode2(in *jlexer.Lexer, out *struct {
	Slot  *int `json:"slot"`
	Block struct {
		BlockTime    *int64     `json:"blockTime,omitempty"`
		ParentSlot   *int       `json:"parentSlot,omitempty"`
		Transactions []SolanaTx `json:"transactions"`
	} `json:"block"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "slot":
			if in.IsNull() {
				in.Skip()
				out.Slot = nil
			} else {
				if out.Slot == nil {
					out.Slot = new(int)
				}
				*out.Slot = int(in.Int())
			}
		case "block":
			easyjson791538f0Decode3(in, &out.Block)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode2(out *jwriter.Writer, in struct {
	Slot  *int `json:"slot"`
	Block struct {
		BlockTime    *int64     `json:"blockTime,omitempty"`
		ParentSlot   *int       `json:"parentSlot,omitempty"`
		Transactions []SolanaTx `json:"transactions"`
	} `json:"block"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"slot\":"
		out.RawString(prefix[1:])
		if in.Slot == nil {
			out.RawString("null")
		} else {
			out.Int(int(*in.Slot))
		}
	}
	{
		const prefix string = ",\"block\":"
		out.RawString(prefix)
		easyjson791538f0Encode3(out, in.Block)
	}
	out.RawByte('}')
}
func easyjson791538f0Decode3(in *jlexer.Lexer, out *struct {
	BlockTime    *int64     `json:"blockTime,omitempty"`
	ParentSlot   *int       `json:"parentSlot,omitempty"`
	Transactions []SolanaTx `json:"transactions"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "blockTime":
			if in.IsNull() {
				in.Skip()
				out.BlockTime = nil
			} else {
				if out.BlockTime == nil {
					out.BlockTime = new(int64)
				}
				*out.BlockTime = int64(in.Int64())
			}
		case "parentSlot":
			if in.IsNull() {
				in.Skip()
				out.ParentSlot = nil
			} else {
				if out.ParentSlot == nil {
					out.ParentSlot = new(int)
				}
				*out.ParentSlot = int(in.Int())
			}
		case "transactions":
			if in.IsNull() {
				in.Skip()
				out.Transactions = nil
			} else {
				in.Delim('[')
				if out.Transactions == nil {
					if !in.IsDelim(']') {
						out.Transactions = make([]SolanaTx, 0, 0)
					} else {
						out.Transactions = []SolanaTx{}
					}
				} else {
					out.Transactions = (out.Transactions)[:0]
				}
				for !in.IsDelim(']') {
					var v1 SolanaTx
					(v1).UnmarshalEasyJSON(in)
					out.Transactions = append(out.Transactions, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode3(out *jwriter.Writer, in struct {
	BlockTime    *int64     `json:"blockTime,omitempty"`
	ParentSlot   *int       `json:"parentSlot,omitempty"`
	Transactions []SolanaTx `json:"transactions"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	if in.BlockTime != nil {
		const prefix string = ",\"blockTime\":"
		first = false
		out.RawString(prefix[1:])
		out.Int64(int64(*in.BlockTime))
	}
	if in.ParentSlot != nil {
		const prefix string = ",\"parentSlot\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(*in.ParentSlot))
	}
	{
		const prefix string = ",\"transactions\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Transactions == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Transactions {
				if v2 > 0 {
					out.RawByte(',')
				}
				(v3).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson791538f0DecodeBlocsyInternalTypes1(in *jlexer.Lexer, out *UITokenAmount) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "amount":
			out.Amount = string(in.String())
		case "decimals":
			out.Decimals = int(in.Int())
		case "uiAmount":
			out.UiAmount = float64(in.Float64())
		case "uiAmountString":
			out.UiAmountString = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes1(out *jwriter.Writer, in UITokenAmount) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"amount\":"
		out.RawString(prefix[1:])
		out.String(string(in.Amount))
	}
	{
		const prefix string = ",\"decimals\":"
		out.RawString(prefix)
		out.Int(int(in.Decimals))
	}
	{
		const prefix string = ",\"uiAmount\":"
		out.RawString(prefix)
		out.Float64(float64(in.UiAmount))
	}
	{
		const prefix string = ",\"uiAmountString\":"
		out.RawString(prefix)
		out.String(string(in.UiAmountString))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v UITokenAmount) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v UITokenAmount) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UITokenAmount) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *UITokenAmount) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes1(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes2(in *jlexer.Lexer, out *TransactionStatus) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Err":
			if m, ok := out.Err.(easyjson.Unmarshaler); ok {
				m.UnmarshalEasyJSON(in)
			} else if m, ok := out.Err.(json.Unmarshaler); ok {
				_ = m.UnmarshalJSON(in.Raw())
			} else {
				out.Err = in.Interface()
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes2(out *jwriter.Writer, in TransactionStatus) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"Err\":"
		out.RawString(prefix[1:])
		if m, ok := in.Err.(easyjson.Marshaler); ok {
			m.MarshalEasyJSON(out)
		} else if m, ok := in.Err.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.Err))
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TransactionStatus) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TransactionStatus) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TransactionStatus) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TransactionStatus) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes2(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes3(in *jlexer.Lexer, out *TransactionMeta) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "err":
			if in.IsNull() {
				in.Skip()
				out.Err = nil
			} else {
				if out.Err == nil {
					out.Err = new(TransactionError)
				}
				(*out.Err).UnmarshalEasyJSON(in)
			}
		case "fee":
			out.Fee = int64(in.Int64())
		case "innerInstructions":
			if in.IsNull() {
				in.Skip()
				out.InnerInstructions = nil
			} else {
				in.Delim('[')
				if out.InnerInstructions == nil {
					if !in.IsDelim(']') {
						out.InnerInstructions = make([]InnerInstruction, 0, 2)
					} else {
						out.InnerInstructions = []InnerInstruction{}
					}
				} else {
					out.InnerInstructions = (out.InnerInstructions)[:0]
				}
				for !in.IsDelim(']') {
					var v4 InnerInstruction
					(v4).UnmarshalEasyJSON(in)
					out.InnerInstructions = append(out.InnerInstructions, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "logMessages":
			if in.IsNull() {
				in.Skip()
				out.LogMessages = nil
			} else {
				in.Delim('[')
				if out.LogMessages == nil {
					if !in.IsDelim(']') {
						out.LogMessages = make([]string, 0, 4)
					} else {
						out.LogMessages = []string{}
					}
				} else {
					out.LogMessages = (out.LogMessages)[:0]
				}
				for !in.IsDelim(']') {
					var v5 string
					v5 = string(in.String())
					out.LogMessages = append(out.LogMessages, v5)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "postBalances":
			if in.IsNull() {
				in.Skip()
				out.PostBalances = nil
			} else {
				in.Delim('[')
				if out.PostBalances == nil {
					if !in.IsDelim(']') {
						out.PostBalances = make([]int64, 0, 8)
					} else {
						out.PostBalances = []int64{}
					}
				} else {
					out.PostBalances = (out.PostBalances)[:0]
				}
				for !in.IsDelim(']') {
					var v6 int64
					v6 = int64(in.Int64())
					out.PostBalances = append(out.PostBalances, v6)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "postTokenBalances":
			if in.IsNull() {
				in.Skip()
				out.PostTokenBalances = nil
			} else {
				in.Delim('[')
				if out.PostTokenBalances == nil {
					if !in.IsDelim(']') {
						out.PostTokenBalances = make([]TokenBalance, 0, 0)
					} else {
						out.PostTokenBalances = []TokenBalance{}
					}
				} else {
					out.PostTokenBalances = (out.PostTokenBalances)[:0]
				}
				for !in.IsDelim(']') {
					var v7 TokenBalance
					(v7).UnmarshalEasyJSON(in)
					out.PostTokenBalances = append(out.PostTokenBalances, v7)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "preBalances":
			if in.IsNull() {
				in.Skip()
				out.PreBalances = nil
			} else {
				in.Delim('[')
				if out.PreBalances == nil {
					if !in.IsDelim(']') {
						out.PreBalances = make([]int64, 0, 8)
					} else {
						out.PreBalances = []int64{}
					}
				} else {
					out.PreBalances = (out.PreBalances)[:0]
				}
				for !in.IsDelim(']') {
					var v8 int64
					v8 = int64(in.Int64())
					out.PreBalances = append(out.PreBalances, v8)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "preTokenBalances":
			if in.IsNull() {
				in.Skip()
				out.PreTokenBalances = nil
			} else {
				in.Delim('[')
				if out.PreTokenBalances == nil {
					if !in.IsDelim(']') {
						out.PreTokenBalances = make([]TokenBalance, 0, 0)
					} else {
						out.PreTokenBalances = []TokenBalance{}
					}
				} else {
					out.PreTokenBalances = (out.PreTokenBalances)[:0]
				}
				for !in.IsDelim(']') {
					var v9 TokenBalance
					(v9).UnmarshalEasyJSON(in)
					out.PreTokenBalances = append(out.PreTokenBalances, v9)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "loadedAddresses":
			if in.IsNull() {
				in.Skip()
				out.LoadedAddresses = nil
			} else {
				if out.LoadedAddresses == nil {
					out.LoadedAddresses = new(struct {
						Readonly []string `json:"readonly"`
						Writable []string `json:"writable"`
					})
				}
				easyjson791538f0Decode4(in, out.LoadedAddresses)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes3(out *jwriter.Writer, in TransactionMeta) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Err != nil {
		const prefix string = ",\"err\":"
		first = false
		out.RawString(prefix[1:])
		(*in.Err).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"fee\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(in.Fee))
	}
	if len(in.InnerInstructions) != 0 {
		const prefix string = ",\"innerInstructions\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v10, v11 := range in.InnerInstructions {
				if v10 > 0 {
					out.RawByte(',')
				}
				(v11).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if len(in.LogMessages) != 0 {
		const prefix string = ",\"logMessages\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v12, v13 := range in.LogMessages {
				if v12 > 0 {
					out.RawByte(',')
				}
				out.String(string(v13))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"postBalances\":"
		out.RawString(prefix)
		if in.PostBalances == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v14, v15 := range in.PostBalances {
				if v14 > 0 {
					out.RawByte(',')
				}
				out.Int64(int64(v15))
			}
			out.RawByte(']')
		}
	}
	if len(in.PostTokenBalances) != 0 {
		const prefix string = ",\"postTokenBalances\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v16, v17 := range in.PostTokenBalances {
				if v16 > 0 {
					out.RawByte(',')
				}
				(v17).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"preBalances\":"
		out.RawString(prefix)
		if in.PreBalances == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v18, v19 := range in.PreBalances {
				if v18 > 0 {
					out.RawByte(',')
				}
				out.Int64(int64(v19))
			}
			out.RawByte(']')
		}
	}
	if len(in.PreTokenBalances) != 0 {
		const prefix string = ",\"preTokenBalances\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v20, v21 := range in.PreTokenBalances {
				if v20 > 0 {
					out.RawByte(',')
				}
				(v21).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if in.LoadedAddresses != nil {
		const prefix string = ",\"loadedAddresses\":"
		out.RawString(prefix)
		easyjson791538f0Encode4(out, *in.LoadedAddresses)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TransactionMeta) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TransactionMeta) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TransactionMeta) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TransactionMeta) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes3(l, v)
}
func easyjson791538f0Decode4(in *jlexer.Lexer, out *struct {
	Readonly []string `json:"readonly"`
	Writable []string `json:"writable"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "readonly":
			if in.IsNull() {
				in.Skip()
				out.Readonly = nil
			} else {
				in.Delim('[')
				if out.Readonly == nil {
					if !in.IsDelim(']') {
						out.Readonly = make([]string, 0, 4)
					} else {
						out.Readonly = []string{}
					}
				} else {
					out.Readonly = (out.Readonly)[:0]
				}
				for !in.IsDelim(']') {
					var v22 string
					v22 = string(in.String())
					out.Readonly = append(out.Readonly, v22)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "writable":
			if in.IsNull() {
				in.Skip()
				out.Writable = nil
			} else {
				in.Delim('[')
				if out.Writable == nil {
					if !in.IsDelim(']') {
						out.Writable = make([]string, 0, 4)
					} else {
						out.Writable = []string{}
					}
				} else {
					out.Writable = (out.Writable)[:0]
				}
				for !in.IsDelim(']') {
					var v23 string
					v23 = string(in.String())
					out.Writable = append(out.Writable, v23)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode4(out *jwriter.Writer, in struct {
	Readonly []string `json:"readonly"`
	Writable []string `json:"writable"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"readonly\":"
		out.RawString(prefix[1:])
		if in.Readonly == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v24, v25 := range in.Readonly {
				if v24 > 0 {
					out.RawByte(',')
				}
				out.String(string(v25))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"writable\":"
		out.RawString(prefix)
		if in.Writable == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v26, v27 := range in.Writable {
				if v26 > 0 {
					out.RawByte(',')
				}
				out.String(string(v27))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson791538f0DecodeBlocsyInternalTypes4(in *jlexer.Lexer, out *TransactionError) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "InstructionError":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('[')
				v28 := 0
				for !in.IsDelim(']') {
					if v28 < 2 {
						if m, ok := (out.InstructionError)[v28].(easyjson.Unmarshaler); ok {
							m.UnmarshalEasyJSON(in)
						} else if m, ok := (out.InstructionError)[v28].(json.Unmarshaler); ok {
							_ = m.UnmarshalJSON(in.Raw())
						} else {
							(out.InstructionError)[v28] = in.Interface()
						}
						v28++
					} else {
						in.SkipRecursive()
					}
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes4(out *jwriter.Writer, in TransactionError) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"InstructionError\":"
		out.RawString(prefix[1:])
		out.RawByte('[')
		for v29 := range in.InstructionError {
			if v29 > 0 {
				out.RawByte(',')
			}
			if m, ok := (in.InstructionError)[v29].(easyjson.Marshaler); ok {
				m.MarshalEasyJSON(out)
			} else if m, ok := (in.InstructionError)[v29].(json.Marshaler); ok {
				out.Raw(m.MarshalJSON())
			} else {
				out.Raw(json.Marshal((in.InstructionError)[v29]))
			}
		}
		out.RawByte(']')
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TransactionError) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TransactionError) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TransactionError) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes4(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TransactionError) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes4(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes5(in *jlexer.Lexer, out *TransactionData) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "message":
			(out.Message).UnmarshalEasyJSON(in)
		case "signatures":
			if in.IsNull() {
				in.Skip()
				out.Signatures = nil
			} else {
				in.Delim('[')
				if out.Signatures == nil {
					if !in.IsDelim(']') {
						out.Signatures = make([]string, 0, 4)
					} else {
						out.Signatures = []string{}
					}
				} else {
					out.Signatures = (out.Signatures)[:0]
				}
				for !in.IsDelim(']') {
					var v30 string
					v30 = string(in.String())
					out.Signatures = append(out.Signatures, v30)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes5(out *jwriter.Writer, in TransactionData) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"message\":"
		out.RawString(prefix[1:])
		(in.Message).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"signatures\":"
		out.RawString(prefix)
		if in.Signatures == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v31, v32 := range in.Signatures {
				if v31 > 0 {
					out.RawByte(',')
				}
				out.String(string(v32))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TransactionData) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes5(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TransactionData) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes5(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TransactionData) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes5(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TransactionData) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes5(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes6(in *jlexer.Lexer, out *TokenInOutData) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "userAccount":
			out.UserAccount = string(in.String())
		case "tokenAccount":
			out.TokenAccount = string(in.String())
		case "mint":
			out.Mint = string(in.String())
		case "TokenAmount":
			easyjson791538f0Decode5(in, &out.TokenAmount)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes6(out *jwriter.Writer, in TokenInOutData) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"userAccount\":"
		out.RawString(prefix[1:])
		out.String(string(in.UserAccount))
	}
	{
		const prefix string = ",\"tokenAccount\":"
		out.RawString(prefix)
		out.String(string(in.TokenAccount))
	}
	{
		const prefix string = ",\"mint\":"
		out.RawString(prefix)
		out.String(string(in.Mint))
	}
	{
		const prefix string = ",\"TokenAmount\":"
		out.RawString(prefix)
		easyjson791538f0Encode5(out, in.TokenAmount)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TokenInOutData) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes6(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TokenInOutData) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes6(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TokenInOutData) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes6(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TokenInOutData) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes6(l, v)
}
func easyjson791538f0Decode5(in *jlexer.Lexer, out *struct {
	Amount   string `json:"amount"`
	Decimals int    `json:"decimals"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "amount":
			out.Amount = string(in.String())
		case "decimals":
			out.Decimals = int(in.Int())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode5(out *jwriter.Writer, in struct {
	Amount   string `json:"amount"`
	Decimals int    `json:"decimals"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"amount\":"
		out.RawString(prefix[1:])
		out.String(string(in.Amount))
	}
	{
		const prefix string = ",\"decimals\":"
		out.RawString(prefix)
		out.Int(int(in.Decimals))
	}
	out.RawByte('}')
}
func easyjson791538f0DecodeBlocsyInternalTypes7(in *jlexer.Lexer, out *TokenBalance) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "accountIndex":
			out.AccountIndex = int(in.Int())
		case "mint":
			out.Mint = string(in.String())
		case "owner":
			out.Owner = string(in.String())
		case "programId":
			out.ProgramId = string(in.String())
		case "uiTokenAmount":
			(out.UITokenAmount).UnmarshalEasyJSON(in)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes7(out *jwriter.Writer, in TokenBalance) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"accountIndex\":"
		out.RawString(prefix[1:])
		out.Int(int(in.AccountIndex))
	}
	{
		const prefix string = ",\"mint\":"
		out.RawString(prefix)
		out.String(string(in.Mint))
	}
	{
		const prefix string = ",\"owner\":"
		out.RawString(prefix)
		out.String(string(in.Owner))
	}
	{
		const prefix string = ",\"programId\":"
		out.RawString(prefix)
		out.String(string(in.ProgramId))
	}
	{
		const prefix string = ",\"uiTokenAmount\":"
		out.RawString(prefix)
		(in.UITokenAmount).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TokenBalance) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes7(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TokenBalance) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes7(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TokenBalance) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes7(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TokenBalance) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes7(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes8(in *jlexer.Lexer, out *SwapBaseOutLog) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "LogType":
			out.LogType = LogType(in.Uint8())
		case "MaxIn":
			out.MaxIn = uint64(in.Uint64())
		case "AmountOut":
			out.AmountOut = uint64(in.Uint64())
		case "Direction":
			out.Direction = uint64(in.Uint64())
		case "UserSource":
			out.UserSource = uint64(in.Uint64())
		case "PoolCoin":
			out.PoolCoin = uint64(in.Uint64())
		case "PoolPC":
			out.PoolPC = uint64(in.Uint64())
		case "DeductIn":
			out.DeductIn = uint64(in.Uint64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes8(out *jwriter.Writer, in SwapBaseOutLog) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"LogType\":"
		out.RawString(prefix[1:])
		out.Uint8(uint8(in.LogType))
	}
	{
		const prefix string = ",\"MaxIn\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.MaxIn))
	}
	{
		const prefix string = ",\"AmountOut\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.AmountOut))
	}
	{
		const prefix string = ",\"Direction\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Direction))
	}
	{
		const prefix string = ",\"UserSource\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.UserSource))
	}
	{
		const prefix string = ",\"PoolCoin\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PoolCoin))
	}
	{
		const prefix string = ",\"PoolPC\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PoolPC))
	}
	{
		const prefix string = ",\"DeductIn\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.DeductIn))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SwapBaseOutLog) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes8(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SwapBaseOutLog) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes8(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SwapBaseOutLog) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes8(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SwapBaseOutLog) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes8(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes9(in *jlexer.Lexer, out *SwapBaseInLog) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "LogType":
			out.LogType = LogType(in.Uint8())
		case "AmountIn":
			out.AmountIn = uint64(in.Uint64())
		case "MinimumOut":
			out.MinimumOut = uint64(in.Uint64())
		case "Direction":
			out.Direction = uint64(in.Uint64())
		case "UserSource":
			out.UserSource = uint64(in.Uint64())
		case "PoolCoin":
			out.PoolCoin = uint64(in.Uint64())
		case "PoolPC":
			out.PoolPC = uint64(in.Uint64())
		case "OutAmount":
			out.OutAmount = uint64(in.Uint64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes9(out *jwriter.Writer, in SwapBaseInLog) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"LogType\":"
		out.RawString(prefix[1:])
		out.Uint8(uint8(in.LogType))
	}
	{
		const prefix string = ",\"AmountIn\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.AmountIn))
	}
	{
		const prefix string = ",\"MinimumOut\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.MinimumOut))
	}
	{
		const prefix string = ",\"Direction\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Direction))
	}
	{
		const prefix string = ",\"UserSource\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.UserSource))
	}
	{
		const prefix string = ",\"PoolCoin\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PoolCoin))
	}
	{
		const prefix string = ",\"PoolPC\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PoolPC))
	}
	{
		const prefix string = ",\"OutAmount\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.OutAmount))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SwapBaseInLog) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes9(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SwapBaseInLog) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes9(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SwapBaseInLog) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes9(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SwapBaseInLog) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes9(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes10(in *jlexer.Lexer, out *SolanaTx) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "meta":
			(out.Meta).UnmarshalEasyJSON(in)
		case "transaction":
			(out.Transaction).UnmarshalEasyJSON(in)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes10(out *jwriter.Writer, in SolanaTx) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"meta\":"
		out.RawString(prefix[1:])
		(in.Meta).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"transaction\":"
		out.RawString(prefix)
		(in.Transaction).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SolanaTx) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes10(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SolanaTx) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes10(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SolanaTx) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes10(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SolanaTx) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes10(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes11(in *jlexer.Lexer, out *SolanaBlockTx) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "tx":
			(out.Tx).UnmarshalEasyJSON(in)
		case "block":
			out.Block = uint64(in.Uint64())
		case "timestamp":
			out.Timestamp = int64(in.Int64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes11(out *jwriter.Writer, in SolanaBlockTx) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"tx\":"
		out.RawString(prefix[1:])
		(in.Tx).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"block\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Block))
	}
	{
		const prefix string = ",\"timestamp\":"
		out.RawString(prefix)
		out.Int64(int64(in.Timestamp))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SolanaBlockTx) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes11(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SolanaBlockTx) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes11(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SolanaBlockTx) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes11(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SolanaBlockTx) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes11(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes12(in *jlexer.Lexer, out *SolTransfer) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "InnerIndex":
			out.InnerIndex = int(in.Int())
		case "IxIndex":
			out.IxIndex = int(in.Int())
		case "ToUserAccount":
			out.ToUserAccount = string(in.String())
		case "ToTokenAccount":
			out.ToTokenAccount = string(in.String())
		case "FromUserAccount":
			out.FromUserAccount = string(in.String())
		case "FromTokenAccount":
			out.FromTokenAccount = string(in.String())
		case "Mint":
			out.Mint = string(in.String())
		case "Decimals":
			out.Decimals = int(in.Int())
		case "Amount":
			out.Amount = string(in.String())
		case "Type":
			out.Type = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes12(out *jwriter.Writer, in SolTransfer) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"InnerIndex\":"
		out.RawString(prefix[1:])
		out.Int(int(in.InnerIndex))
	}
	{
		const prefix string = ",\"IxIndex\":"
		out.RawString(prefix)
		out.Int(int(in.IxIndex))
	}
	{
		const prefix string = ",\"ToUserAccount\":"
		out.RawString(prefix)
		out.String(string(in.ToUserAccount))
	}
	{
		const prefix string = ",\"ToTokenAccount\":"
		out.RawString(prefix)
		out.String(string(in.ToTokenAccount))
	}
	{
		const prefix string = ",\"FromUserAccount\":"
		out.RawString(prefix)
		out.String(string(in.FromUserAccount))
	}
	{
		const prefix string = ",\"FromTokenAccount\":"
		out.RawString(prefix)
		out.String(string(in.FromTokenAccount))
	}
	{
		const prefix string = ",\"Mint\":"
		out.RawString(prefix)
		out.String(string(in.Mint))
	}
	{
		const prefix string = ",\"Decimals\":"
		out.RawString(prefix)
		out.Int(int(in.Decimals))
	}
	{
		const prefix string = ",\"Amount\":"
		out.RawString(prefix)
		out.String(string(in.Amount))
	}
	{
		const prefix string = ",\"Type\":"
		out.RawString(prefix)
		out.String(string(in.Type))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SolTransfer) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes12(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SolTransfer) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes12(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SolTransfer) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes12(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SolTransfer) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes12(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes13(in *jlexer.Lexer, out *SolSwapData) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "nativeInput":
			(out.NativeInput).UnmarshalEasyJSON(in)
		case "nativeOutput":
			(out.NativeOutput).UnmarshalEasyJSON(in)
		case "tokenInputs":
			if in.IsNull() {
				in.Skip()
				out.TokenInputs = nil
			} else {
				in.Delim('[')
				if out.TokenInputs == nil {
					if !in.IsDelim(']') {
						out.TokenInputs = make([]TokenInOutData, 0, 0)
					} else {
						out.TokenInputs = []TokenInOutData{}
					}
				} else {
					out.TokenInputs = (out.TokenInputs)[:0]
				}
				for !in.IsDelim(']') {
					var v33 TokenInOutData
					(v33).UnmarshalEasyJSON(in)
					out.TokenInputs = append(out.TokenInputs, v33)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "tokenOutputs":
			if in.IsNull() {
				in.Skip()
				out.TokenOutputs = nil
			} else {
				in.Delim('[')
				if out.TokenOutputs == nil {
					if !in.IsDelim(']') {
						out.TokenOutputs = make([]TokenInOutData, 0, 0)
					} else {
						out.TokenOutputs = []TokenInOutData{}
					}
				} else {
					out.TokenOutputs = (out.TokenOutputs)[:0]
				}
				for !in.IsDelim(']') {
					var v34 TokenInOutData
					(v34).UnmarshalEasyJSON(in)
					out.TokenOutputs = append(out.TokenOutputs, v34)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "innerSwaps":
			if in.IsNull() {
				in.Skip()
				out.InnerSwaps = nil
			} else {
				in.Delim('[')
				if out.InnerSwaps == nil {
					if !in.IsDelim(']') {
						out.InnerSwaps = make([]InnerSwap, 0, 0)
					} else {
						out.InnerSwaps = []InnerSwap{}
					}
				} else {
					out.InnerSwaps = (out.InnerSwaps)[:0]
				}
				for !in.IsDelim(']') {
					var v35 InnerSwap
					(v35).UnmarshalEasyJSON(in)
					out.InnerSwaps = append(out.InnerSwaps, v35)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes13(out *jwriter.Writer, in SolSwapData) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"nativeInput\":"
		out.RawString(prefix[1:])
		(in.NativeInput).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"nativeOutput\":"
		out.RawString(prefix)
		(in.NativeOutput).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"tokenInputs\":"
		out.RawString(prefix)
		if in.TokenInputs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v36, v37 := range in.TokenInputs {
				if v36 > 0 {
					out.RawByte(',')
				}
				(v37).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"tokenOutputs\":"
		out.RawString(prefix)
		if in.TokenOutputs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v38, v39 := range in.TokenOutputs {
				if v38 > 0 {
					out.RawByte(',')
				}
				(v39).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"innerSwaps\":"
		out.RawString(prefix)
		if in.InnerSwaps == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v40, v41 := range in.InnerSwaps {
				if v40 > 0 {
					out.RawByte(',')
				}
				(v41).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SolSwapData) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes13(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SolSwapData) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes13(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SolSwapData) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes13(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SolSwapData) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes13(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes14(in *jlexer.Lexer, out *SolSwap) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Pair":
			out.Pair = string(in.String())
		case "Exchange":
			out.Exchange = string(in.String())
		case "TokenOut":
			out.TokenOut = string(in.String())
		case "TokenIn":
			out.TokenIn = string(in.String())
		case "AmountOut":
			out.AmountOut = string(in.String())
		case "AmountIn":
			out.AmountIn = string(in.String())
		case "Wallet":
			out.Wallet = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes14(out *jwriter.Writer, in SolSwap) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"Pair\":"
		out.RawString(prefix[1:])
		out.String(string(in.Pair))
	}
	{
		const prefix string = ",\"Exchange\":"
		out.RawString(prefix)
		out.String(string(in.Exchange))
	}
	{
		const prefix string = ",\"TokenOut\":"
		out.RawString(prefix)
		out.String(string(in.TokenOut))
	}
	{
		const prefix string = ",\"TokenIn\":"
		out.RawString(prefix)
		out.String(string(in.TokenIn))
	}
	{
		const prefix string = ",\"AmountOut\":"
		out.RawString(prefix)
		out.String(string(in.AmountOut))
	}
	{
		const prefix string = ",\"AmountIn\":"
		out.RawString(prefix)
		out.String(string(in.AmountIn))
	}
	{
		const prefix string = ",\"Wallet\":"
		out.RawString(prefix)
		out.String(string(in.Wallet))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SolSwap) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes14(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SolSwap) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes14(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SolSwap) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes14(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SolSwap) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes14(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes15(in *jlexer.Lexer, out *SolBalanceDiff) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "token":
			out.Mint = string(in.String())
		case "decimals":
			out.Decimals = int(in.Int())
		case "amount":
			out.Amount = string(in.String())
		case "owner":
			out.Owner = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes15(out *jwriter.Writer, in SolBalanceDiff) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"token\":"
		out.RawString(prefix[1:])
		out.String(string(in.Mint))
	}
	{
		const prefix string = ",\"decimals\":"
		out.RawString(prefix)
		out.Int(int(in.Decimals))
	}
	{
		const prefix string = ",\"amount\":"
		out.RawString(prefix)
		out.String(string(in.Amount))
	}
	{
		const prefix string = ",\"owner\":"
		out.RawString(prefix)
		out.String(string(in.Owner))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v SolBalanceDiff) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes15(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v SolBalanceDiff) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes15(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *SolBalanceDiff) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes15(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *SolBalanceDiff) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes15(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes16(in *jlexer.Lexer, out *RaySwapLog) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "LogType":
			out.LogType = LogType(in.Uint8())
		case "AmountIn":
			out.AmountIn = uint64(in.Uint64())
		case "MinimumOut":
			out.MinimumOut = uint64(in.Uint64())
		case "Direction":
			out.Direction = uint64(in.Uint64())
		case "UserSource":
			out.UserSource = uint64(in.Uint64())
		case "PoolCoin":
			out.PoolCoin = uint64(in.Uint64())
		case "PoolPC":
			out.PoolPC = uint64(in.Uint64())
		case "OutAmount":
			out.OutAmount = uint64(in.Uint64())
		case "MaxIn":
			out.MaxIn = uint64(in.Uint64())
		case "AmountOut":
			out.AmountOut = uint64(in.Uint64())
		case "DeductIn":
			out.DeductIn = uint64(in.Uint64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes16(out *jwriter.Writer, in RaySwapLog) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"LogType\":"
		out.RawString(prefix[1:])
		out.Uint8(uint8(in.LogType))
	}
	{
		const prefix string = ",\"AmountIn\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.AmountIn))
	}
	{
		const prefix string = ",\"MinimumOut\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.MinimumOut))
	}
	{
		const prefix string = ",\"Direction\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Direction))
	}
	{
		const prefix string = ",\"UserSource\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.UserSource))
	}
	{
		const prefix string = ",\"PoolCoin\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PoolCoin))
	}
	{
		const prefix string = ",\"PoolPC\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.PoolPC))
	}
	{
		const prefix string = ",\"OutAmount\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.OutAmount))
	}
	{
		const prefix string = ",\"MaxIn\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.MaxIn))
	}
	{
		const prefix string = ",\"AmountOut\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.AmountOut))
	}
	{
		const prefix string = ",\"DeductIn\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.DeductIn))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v RaySwapLog) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes16(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v RaySwapLog) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes16(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *RaySwapLog) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes16(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *RaySwapLog) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes16(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes17(in *jlexer.Lexer, out *PoolInit) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "nonce":
			out.Nonce = int64(in.Int64())
		case "open_time":
			out.OpenTime = int64(in.Int64())
		case "init_pc_amount":
			out.InitPcAmount = int64(in.Int64())
		case "init_coin_amount":
			out.InitCoinAmount = int64(in.Int64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes17(out *jwriter.Writer, in PoolInit) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"nonce\":"
		out.RawString(prefix[1:])
		out.Int64(int64(in.Nonce))
	}
	{
		const prefix string = ",\"open_time\":"
		out.RawString(prefix)
		out.Int64(int64(in.OpenTime))
	}
	{
		const prefix string = ",\"init_pc_amount\":"
		out.RawString(prefix)
		out.Int64(int64(in.InitPcAmount))
	}
	{
		const prefix string = ",\"init_coin_amount\":"
		out.RawString(prefix)
		out.Int64(int64(in.InitCoinAmount))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v PoolInit) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes17(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v PoolInit) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes17(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *PoolInit) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes17(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *PoolInit) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes17(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes18(in *jlexer.Lexer, out *ParsedDataInfo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "amount":
			if in.IsNull() {
				in.Skip()
				out.Amount = nil
			} else {
				if out.Amount == nil {
					out.Amount = new(string)
				}
				*out.Amount = string(in.String())
			}
		case "destination":
			if in.IsNull() {
				in.Skip()
				out.Destination = nil
			} else {
				if out.Destination == nil {
					out.Destination = new(string)
				}
				*out.Destination = string(in.String())
			}
		case "source":
			if in.IsNull() {
				in.Skip()
				out.Source = nil
			} else {
				if out.Source == nil {
					out.Source = new(string)
				}
				*out.Source = string(in.String())
			}
		case "authority":
			if in.IsNull() {
				in.Skip()
				out.Authority = nil
			} else {
				if out.Authority == nil {
					out.Authority = new(string)
				}
				*out.Authority = string(in.String())
			}
		case "mint":
			if in.IsNull() {
				in.Skip()
				out.Mint = nil
			} else {
				if out.Mint == nil {
					out.Mint = new(string)
				}
				*out.Mint = string(in.String())
			}
		case "wallet":
			if in.IsNull() {
				in.Skip()
				out.Wallet = nil
			} else {
				if out.Wallet == nil {
					out.Wallet = new(string)
				}
				*out.Wallet = string(in.String())
			}
		case "tokenAmount":
			if in.IsNull() {
				in.Skip()
				out.TokenAmount = nil
			} else {
				if out.TokenAmount == nil {
					out.TokenAmount = new(UITokenAmount)
				}
				(*out.TokenAmount).UnmarshalEasyJSON(in)
			}
		case "account":
			if in.IsNull() {
				in.Skip()
				out.Account = nil
			} else {
				if out.Account == nil {
					out.Account = new(string)
				}
				*out.Account = string(in.String())
			}
		case "newAccount":
			if in.IsNull() {
				in.Skip()
				out.NewAccount = nil
			} else {
				if out.NewAccount == nil {
					out.NewAccount = new(string)
				}
				*out.NewAccount = string(in.String())
			}
		case "owner":
			if in.IsNull() {
				in.Skip()
				out.Owner = nil
			} else {
				if out.Owner == nil {
					out.Owner = new(string)
				}
				*out.Owner = string(in.String())
			}
		case "lamports":
			if in.IsNull() {
				in.Skip()
				out.Lamports = nil
			} else {
				if out.Lamports == nil {
					out.Lamports = new(int64)
				}
				*out.Lamports = int64(in.Int64())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes18(out *jwriter.Writer, in ParsedDataInfo) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Amount != nil {
		const prefix string = ",\"amount\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(*in.Amount))
	}
	if in.Destination != nil {
		const prefix string = ",\"destination\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Destination))
	}
	if in.Source != nil {
		const prefix string = ",\"source\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Source))
	}
	if in.Authority != nil {
		const prefix string = ",\"authority\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Authority))
	}
	if in.Mint != nil {
		const prefix string = ",\"mint\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Mint))
	}
	if in.Wallet != nil {
		const prefix string = ",\"wallet\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Wallet))
	}
	if in.TokenAmount != nil {
		const prefix string = ",\"tokenAmount\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(*in.TokenAmount).MarshalEasyJSON(out)
	}
	if in.Account != nil {
		const prefix string = ",\"account\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Account))
	}
	if in.NewAccount != nil {
		const prefix string = ",\"newAccount\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.NewAccount))
	}
	if in.Owner != nil {
		const prefix string = ",\"owner\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(*in.Owner))
	}
	if in.Lamports != nil {
		const prefix string = ",\"lamports\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int64(int64(*in.Lamports))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ParsedDataInfo) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes18(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ParsedDataInfo) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes18(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ParsedDataInfo) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes18(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ParsedDataInfo) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes18(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes19(in *jlexer.Lexer, out *NativeInOutData) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "account":
			out.Account = string(in.String())
		case "amount":
			out.Amount = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes19(out *jwriter.Writer, in NativeInOutData) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"account\":"
		out.RawString(prefix[1:])
		out.String(string(in.Account))
	}
	{
		const prefix string = ",\"amount\":"
		out.RawString(prefix)
		out.String(string(in.Amount))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v NativeInOutData) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes19(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v NativeInOutData) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes19(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *NativeInOutData) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes19(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *NativeInOutData) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes19(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes20(in *jlexer.Lexer, out *Message) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "accountKeys":
			if in.IsNull() {
				in.Skip()
				out.AccountKeys = nil
			} else {
				in.Delim('[')
				if out.AccountKeys == nil {
					if !in.IsDelim(']') {
						out.AccountKeys = make([]string, 0, 4)
					} else {
						out.AccountKeys = []string{}
					}
				} else {
					out.AccountKeys = (out.AccountKeys)[:0]
				}
				for !in.IsDelim(']') {
					var v42 string
					v42 = string(in.String())
					out.AccountKeys = append(out.AccountKeys, v42)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "addressTableLookups":
			if in.IsNull() {
				in.Skip()
				out.AddressTableLookups = nil
			} else {
				in.Delim('[')
				if out.AddressTableLookups == nil {
					if !in.IsDelim(']') {
						out.AddressTableLookups = make([]AddressTableLookup, 0, 1)
					} else {
						out.AddressTableLookups = []AddressTableLookup{}
					}
				} else {
					out.AddressTableLookups = (out.AddressTableLookups)[:0]
				}
				for !in.IsDelim(']') {
					var v43 AddressTableLookup
					(v43).UnmarshalEasyJSON(in)
					out.AddressTableLookups = append(out.AddressTableLookups, v43)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "instructions":
			if in.IsNull() {
				in.Skip()
				out.Instructions = nil
			} else {
				in.Delim('[')
				if out.Instructions == nil {
					if !in.IsDelim(']') {
						out.Instructions = make([]Instruction, 0, 1)
					} else {
						out.Instructions = []Instruction{}
					}
				} else {
					out.Instructions = (out.Instructions)[:0]
				}
				for !in.IsDelim(']') {
					var v44 Instruction
					(v44).UnmarshalEasyJSON(in)
					out.Instructions = append(out.Instructions, v44)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "recentBlockhash":
			out.RecentBlockhash = string(in.String())
		case "header":
			if m, ok := out.Header.(easyjson.Unmarshaler); ok {
				m.UnmarshalEasyJSON(in)
			} else if m, ok := out.Header.(json.Unmarshaler); ok {
				_ = m.UnmarshalJSON(in.Raw())
			} else {
				out.Header = in.Interface()
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes20(out *jwriter.Writer, in Message) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"accountKeys\":"
		out.RawString(prefix[1:])
		if in.AccountKeys == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v45, v46 := range in.AccountKeys {
				if v45 > 0 {
					out.RawByte(',')
				}
				out.String(string(v46))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"addressTableLookups\":"
		out.RawString(prefix)
		if in.AddressTableLookups == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v47, v48 := range in.AddressTableLookups {
				if v47 > 0 {
					out.RawByte(',')
				}
				(v48).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"instructions\":"
		out.RawString(prefix)
		if in.Instructions == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v49, v50 := range in.Instructions {
				if v49 > 0 {
					out.RawByte(',')
				}
				(v50).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"recentBlockhash\":"
		out.RawString(prefix)
		out.String(string(in.RecentBlockhash))
	}
	if in.Header != nil {
		const prefix string = ",\"header\":"
		out.RawString(prefix)
		if m, ok := in.Header.(easyjson.Marshaler); ok {
			m.MarshalEasyJSON(out)
		} else if m, ok := in.Header.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.Header))
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Message) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes20(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Message) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes20(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Message) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes20(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Message) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes20(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes21(in *jlexer.Lexer, out *Instruction) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "accounts":
			if in.IsNull() {
				in.Skip()
				out.Accounts = nil
			} else {
				in.Delim('[')
				if out.Accounts == nil {
					if !in.IsDelim(']') {
						out.Accounts = make([]int, 0, 8)
					} else {
						out.Accounts = []int{}
					}
				} else {
					out.Accounts = (out.Accounts)[:0]
				}
				for !in.IsDelim(']') {
					var v51 int
					v51 = int(in.Int())
					out.Accounts = append(out.Accounts, v51)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "data":
			out.Data = string(in.String())
		case "programIdIndex":
			out.ProgramIdIndex = int(in.Int())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes21(out *jwriter.Writer, in Instruction) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"accounts\":"
		out.RawString(prefix[1:])
		if in.Accounts == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v52, v53 := range in.Accounts {
				if v52 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v53))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"data\":"
		out.RawString(prefix)
		out.String(string(in.Data))
	}
	{
		const prefix string = ",\"programIdIndex\":"
		out.RawString(prefix)
		out.Int(int(in.ProgramIdIndex))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Instruction) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes21(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Instruction) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes21(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Instruction) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes21(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Instruction) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes21(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes22(in *jlexer.Lexer, out *InnerSwap) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "tokenInputs":
			if in.IsNull() {
				in.Skip()
				out.TokenInputs = nil
			} else {
				in.Delim('[')
				if out.TokenInputs == nil {
					if !in.IsDelim(']') {
						out.TokenInputs = make([]TokenInOutData, 0, 0)
					} else {
						out.TokenInputs = []TokenInOutData{}
					}
				} else {
					out.TokenInputs = (out.TokenInputs)[:0]
				}
				for !in.IsDelim(']') {
					var v54 TokenInOutData
					(v54).UnmarshalEasyJSON(in)
					out.TokenInputs = append(out.TokenInputs, v54)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "tokenOutputs":
			if in.IsNull() {
				in.Skip()
				out.TokenOutputs = nil
			} else {
				in.Delim('[')
				if out.TokenOutputs == nil {
					if !in.IsDelim(']') {
						out.TokenOutputs = make([]TokenInOutData, 0, 0)
					} else {
						out.TokenOutputs = []TokenInOutData{}
					}
				} else {
					out.TokenOutputs = (out.TokenOutputs)[:0]
				}
				for !in.IsDelim(']') {
					var v55 TokenInOutData
					(v55).UnmarshalEasyJSON(in)
					out.TokenOutputs = append(out.TokenOutputs, v55)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "ProgramInfo":
			easyjson791538f0Decode6(in, &out.ProgramInfo)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes22(out *jwriter.Writer, in InnerSwap) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"tokenInputs\":"
		out.RawString(prefix[1:])
		if in.TokenInputs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v56, v57 := range in.TokenInputs {
				if v56 > 0 {
					out.RawByte(',')
				}
				(v57).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"tokenOutputs\":"
		out.RawString(prefix)
		if in.TokenOutputs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v58, v59 := range in.TokenOutputs {
				if v58 > 0 {
					out.RawByte(',')
				}
				(v59).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"ProgramInfo\":"
		out.RawString(prefix)
		easyjson791538f0Encode6(out, in.ProgramInfo)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v InnerSwap) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes22(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v InnerSwap) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes22(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *InnerSwap) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes22(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *InnerSwap) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes22(l, v)
}
func easyjson791538f0Decode6(in *jlexer.Lexer, out *struct {
	Source      string `json:"source"`
	Account     string `json:"account"`
	ProgramName string `json:"programName"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "source":
			out.Source = string(in.String())
		case "account":
			out.Account = string(in.String())
		case "programName":
			out.ProgramName = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode6(out *jwriter.Writer, in struct {
	Source      string `json:"source"`
	Account     string `json:"account"`
	ProgramName string `json:"programName"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"source\":"
		out.RawString(prefix[1:])
		out.String(string(in.Source))
	}
	{
		const prefix string = ",\"account\":"
		out.RawString(prefix)
		out.String(string(in.Account))
	}
	{
		const prefix string = ",\"programName\":"
		out.RawString(prefix)
		out.String(string(in.ProgramName))
	}
	out.RawByte('}')
}
func easyjson791538f0DecodeBlocsyInternalTypes23(in *jlexer.Lexer, out *InnerInstruction) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "index":
			out.Index = int(in.Int())
		case "instructions":
			if in.IsNull() {
				in.Skip()
				out.Instructions = nil
			} else {
				in.Delim('[')
				if out.Instructions == nil {
					if !in.IsDelim(']') {
						out.Instructions = make([]Instruction, 0, 1)
					} else {
						out.Instructions = []Instruction{}
					}
				} else {
					out.Instructions = (out.Instructions)[:0]
				}
				for !in.IsDelim(']') {
					var v60 Instruction
					(v60).UnmarshalEasyJSON(in)
					out.Instructions = append(out.Instructions, v60)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes23(out *jwriter.Writer, in InnerInstruction) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"index\":"
		out.RawString(prefix[1:])
		out.Int(int(in.Index))
	}
	{
		const prefix string = ",\"instructions\":"
		out.RawString(prefix)
		if in.Instructions == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v61, v62 := range in.Instructions {
				if v61 > 0 {
					out.RawByte(',')
				}
				(v62).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v InnerInstruction) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes23(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v InnerInstruction) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes23(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *InnerInstruction) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes23(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *InnerInstruction) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes23(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes24(in *jlexer.Lexer, out *HTTPTxMessage) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "result":
			(out.Result).UnmarshalEasyJSON(in)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes24(out *jwriter.Writer, in HTTPTxMessage) {
	out.RawByte('{')
	first := true
	_ = first
	if true {
		const prefix string = ",\"result\":"
		first = false
		out.RawString(prefix[1:])
		(in.Result).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v HTTPTxMessage) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes24(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v HTTPTxMessage) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes24(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HTTPTxMessage) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes24(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HTTPTxMessage) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes24(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes25(in *jlexer.Lexer, out *HTTPBlockMessage) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "result":
			if in.IsNull() {
				in.Skip()
				out.Result = nil
			} else {
				if out.Result == nil {
					out.Result = new(BlockResult)
				}
				(*out.Result).UnmarshalEasyJSON(in)
			}
		case "error":
			if in.IsNull() {
				in.Skip()
				out.Error = nil
			} else {
				if out.Error == nil {
					out.Error = new(struct {
						Code    int    `json:"code"`
						Message string `json:"message"`
					})
				}
				easyjson791538f0Decode7(in, out.Error)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes25(out *jwriter.Writer, in HTTPBlockMessage) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Result != nil {
		const prefix string = ",\"result\":"
		first = false
		out.RawString(prefix[1:])
		(*in.Result).MarshalEasyJSON(out)
	}
	if in.Error != nil {
		const prefix string = ",\"error\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjson791538f0Encode7(out, *in.Error)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v HTTPBlockMessage) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes25(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v HTTPBlockMessage) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes25(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HTTPBlockMessage) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes25(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HTTPBlockMessage) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes25(l, v)
}
func easyjson791538f0Decode7(in *jlexer.Lexer, out *struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "code":
			out.Code = int(in.Int())
		case "message":
			out.Message = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0Encode7(out *jwriter.Writer, in struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"code\":"
		out.RawString(prefix[1:])
		out.Int(int(in.Code))
	}
	{
		const prefix string = ",\"message\":"
		out.RawString(prefix)
		out.String(string(in.Message))
	}
	out.RawByte('}')
}
func easyjson791538f0DecodeBlocsyInternalTypes26(in *jlexer.Lexer, out *BlockResult) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "blockTime":
			out.BlockTime = int64(in.Int64())
		case "parentSlot":
			out.ParentSlot = int(in.Int())
		case "transactions":
			if in.IsNull() {
				in.Skip()
				out.Transactions = nil
			} else {
				in.Delim('[')
				if out.Transactions == nil {
					if !in.IsDelim(']') {
						out.Transactions = make([]SolanaTx, 0, 0)
					} else {
						out.Transactions = []SolanaTx{}
					}
				} else {
					out.Transactions = (out.Transactions)[:0]
				}
				for !in.IsDelim(']') {
					var v63 SolanaTx
					(v63).UnmarshalEasyJSON(in)
					out.Transactions = append(out.Transactions, v63)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes26(out *jwriter.Writer, in BlockResult) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"blockTime\":"
		out.RawString(prefix[1:])
		out.Int64(int64(in.BlockTime))
	}
	{
		const prefix string = ",\"parentSlot\":"
		out.RawString(prefix)
		out.Int(int(in.ParentSlot))
	}
	{
		const prefix string = ",\"transactions\":"
		out.RawString(prefix)
		if in.Transactions == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v64, v65 := range in.Transactions {
				if v64 > 0 {
					out.RawByte(',')
				}
				(v65).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v BlockResult) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes26(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BlockResult) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes26(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BlockResult) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes26(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BlockResult) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes26(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes27(in *jlexer.Lexer, out *BlockData) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "transactions":
			if in.IsNull() {
				in.Skip()
				out.Transactions = nil
			} else {
				in.Delim('[')
				if out.Transactions == nil {
					if !in.IsDelim(']') {
						out.Transactions = make([]SolanaTx, 0, 0)
					} else {
						out.Transactions = []SolanaTx{}
					}
				} else {
					out.Transactions = (out.Transactions)[:0]
				}
				for !in.IsDelim(']') {
					var v66 SolanaTx
					(v66).UnmarshalEasyJSON(in)
					out.Transactions = append(out.Transactions, v66)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "blockTime":
			out.Timestamp = int64(in.Int64())
		case "block":
			out.Block = uint64(in.Uint64())
		case "ignoreWS":
			out.IgnoreWS = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes27(out *jwriter.Writer, in BlockData) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"transactions\":"
		out.RawString(prefix[1:])
		if in.Transactions == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v67, v68 := range in.Transactions {
				if v67 > 0 {
					out.RawByte(',')
				}
				(v68).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"blockTime\":"
		out.RawString(prefix)
		out.Int64(int64(in.Timestamp))
	}
	{
		const prefix string = ",\"block\":"
		out.RawString(prefix)
		out.Uint64(uint64(in.Block))
	}
	{
		const prefix string = ",\"ignoreWS\":"
		out.RawString(prefix)
		out.Bool(bool(in.IgnoreWS))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v BlockData) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes27(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v BlockData) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes27(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *BlockData) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes27(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *BlockData) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes27(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes28(in *jlexer.Lexer, out *AddressTableLookup) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "accountKey":
			out.AccountKey = string(in.String())
		case "readonlyIndexes":
			if in.IsNull() {
				in.Skip()
				out.ReadonlyIndexes = nil
			} else {
				in.Delim('[')
				if out.ReadonlyIndexes == nil {
					if !in.IsDelim(']') {
						out.ReadonlyIndexes = make([]int, 0, 8)
					} else {
						out.ReadonlyIndexes = []int{}
					}
				} else {
					out.ReadonlyIndexes = (out.ReadonlyIndexes)[:0]
				}
				for !in.IsDelim(']') {
					var v69 int
					v69 = int(in.Int())
					out.ReadonlyIndexes = append(out.ReadonlyIndexes, v69)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "writableIndexes":
			if in.IsNull() {
				in.Skip()
				out.WritableIndexes = nil
			} else {
				in.Delim('[')
				if out.WritableIndexes == nil {
					if !in.IsDelim(']') {
						out.WritableIndexes = make([]int, 0, 8)
					} else {
						out.WritableIndexes = []int{}
					}
				} else {
					out.WritableIndexes = (out.WritableIndexes)[:0]
				}
				for !in.IsDelim(']') {
					var v70 int
					v70 = int(in.Int())
					out.WritableIndexes = append(out.WritableIndexes, v70)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes28(out *jwriter.Writer, in AddressTableLookup) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"accountKey\":"
		out.RawString(prefix[1:])
		out.String(string(in.AccountKey))
	}
	{
		const prefix string = ",\"readonlyIndexes\":"
		out.RawString(prefix)
		if in.ReadonlyIndexes == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v71, v72 := range in.ReadonlyIndexes {
				if v71 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v72))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"writableIndexes\":"
		out.RawString(prefix)
		if in.WritableIndexes == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v73, v74 := range in.WritableIndexes {
				if v73 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v74))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v AddressTableLookup) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes28(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v AddressTableLookup) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes28(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *AddressTableLookup) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes28(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *AddressTableLookup) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes28(l, v)
}
func easyjson791538f0DecodeBlocsyInternalTypes29(in *jlexer.Lexer, out *AccountKey) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "pubkey":
			out.Pubkey = string(in.String())
		case "signer":
			out.Signer = bool(in.Bool())
		case "source":
			out.Source = string(in.String())
		case "writable":
			out.Writable = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson791538f0EncodeBlocsyInternalTypes29(out *jwriter.Writer, in AccountKey) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"pubkey\":"
		out.RawString(prefix[1:])
		out.String(string(in.Pubkey))
	}
	{
		const prefix string = ",\"signer\":"
		out.RawString(prefix)
		out.Bool(bool(in.Signer))
	}
	{
		const prefix string = ",\"source\":"
		out.RawString(prefix)
		out.String(string(in.Source))
	}
	{
		const prefix string = ",\"writable\":"
		out.RawString(prefix)
		out.Bool(bool(in.Writable))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v AccountKey) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson791538f0EncodeBlocsyInternalTypes29(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v AccountKey) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson791538f0EncodeBlocsyInternalTypes29(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *AccountKey) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson791538f0DecodeBlocsyInternalTypes29(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *AccountKey) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson791538f0DecodeBlocsyInternalTypes29(l, v)
}
